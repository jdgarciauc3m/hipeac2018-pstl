\begin{frame}[t,fragile]{¿Qué es la programación genérica?}
\begin{itemize}
  \item Una aproximación que permite generalizar entidades de un programa.
    \begin{itemize}
      \item A veces llamado \emph{polimorfismo paramétrico}.
      \item Proporciona \emph{polimorfismo en tiempo de compilación} frente al
            \emph{polimorfismo dinámico} de la orientación a objetos.
      \item Muy buena combinación de flexibilidad y rendimiento.
    \end{itemize}
  \item ¿Qué entidades se pueden generalizar?
    \begin{itemize}
      \item Clases y funciones.
    \end{itemize}
  \item ¿Qué se puede usar como parámetro del genérico?
    \begin{itemize}
      \item Un tipo.
      \item Un valor entero.
    \end{itemize}
\end{itemize}
\begin{block}{Ejemplo}
\begin{lstlisting}[]
template <class T, int N> class buffer { /* ... */ };
buffer<int,100> b1;
buffer<char,20> b2;
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Plantillas: Definición de tipos genéricos}
\begin{itemize}
  \item Una \alert{plantilla} permite usar un tipo de datos que está
        parametrizado por otro tipo de datos.
\begin{lstlisting}[]
vector<double> v;
vector<int> w;
map<string,int> d;
vector<vector<string>> x;
\end{lstlisting}
  \item Una plantilla requiere que todas las definiciones sean visibles
        en tiempo de compilación (no de enlace).
    \begin{itemize}
      \item Efecto práctico: Todas las definiciones en cabeceras.
    \end{itemize}
\begin{lstlisting}[]
template <typename T>
class vector {
//...
};

template <typename K, typename V>
class map {
// ...
};
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Una clase genérica vector}
\begin{block}{vector.h (I)}
\begin{lstlisting}[]
template <typename T>
class vector {
public:
  vector();
  explicit vector(int n);
  vector(std::initializer_list<T> il);

  vector(const vector &);
  vector & operator=(const vector &);

  vector(vector &&) = default;
  vector & operator=(vector &&) = default;

  T operator[](int i) const { return vec[i]; }
  T & operator[](int i) { return vec[i]; }

  // ...
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Una clase genérica vector}
\begin{block}{vector.h (II)}
\begin{lstlisting}[]
  unsigned long num_elems() const { return tam; }
  unsigned long capacidad() const { return total; }

  void reserva(int n);
  void redimensiona(int n);
  void agrega_final(const T & x);

private:
  unsigned long tam;
  unsinged long total;
  std::unique_ptr<T[]> vec;
};

//...
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Implementando funciones miembro}
\begin{block}{vector.h (III)}
\begin{lstlisting}[]
template <typename T>
vector<T>::vector() :
  tam{0}, total{0}, vec{nullptr}
{}

template <typename T>
vector<T>::vector(int n) :
  tam{(n>0)?static_cast<unsigned long>(n):0},
  total{tam},
  vec{make_unique<T[]>(total)}
{}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Parámetros de plantilla no-tipo}
\begin{itemize}
  \item Se puede definir una plantilla en la que un parámetro no es un tipo
        sino un valor.
\begin{lstlisting}[]
template <typename T, int N>
struct array {
  // ...
};
\end{lstlisting}
  \item Los valores usados para la instanciación deben ser conocidos en tiempo
        de compilación.
\begin{lstlisting}[]
array<double,1024> v1; // OK

constexpr int max = 512;
array<double, max> v2; // OK

int tam = 256;
array<double, tam> v3; // Error
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Una plantilla para arrays}
\begin{block}{array.h}
\begin{lstlisting}[]
template <typename T, int N>
struct array {
  T vec[N];

  T & operator[](int i) { return vec[i]; }
  const T & operator[](int i) const { return vec[i]; }
  int tam() const { return N; }
};

void f() {
  array<int,12> v;
  for (int i=0;i<12;++i) {
    v[i] = 2 * i;
  }
  for (int i=0;i<12;++i) {
    cout << v[i] << endl;
  }
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Plantillas de función}
\begin{itemize}
  \item Se puede usar una plantilla para definir de forma genérica una
        familia de funciones.
\begin{lstlisting}[]
template <typename O, typename C>
void imprime(O & os, const C & c, string sep) {
  for (auto & x : c) {
    os << x << sep;
  }
}
\end{lstlisting}
  \item Los parámetros de plantilla se deducen en la invocación.
\begin{lstlisting}[]
void f() {
  vector<string> v1 {"C++", "is", "faster", "than", "C"};
  array<double,4> v2 {1.0, 2.0, 3.0, 4.0};
  imprime(cout, v1, "\n"); // O->ostream, C->vector<string>
  imprime(cout, v2, ", "); // O->ostream, C->vector<double>
}
\end{lstlisting}
\end{itemize}
\end{frame}
