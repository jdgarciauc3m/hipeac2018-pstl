\begin{frame}[t]{STL: Standard Template Library}
\begin{itemize}
  \item Originalmente diseñada por Alexander Stepanov.
  \item Objetivo original: \emph{``la representación más general,
        más eficiente y más flexible de conceptos''}.
    \begin{itemize}
      \item Representar conceptos separados de forma separada en el código.
      \item Combinar conceptos libremente siempre que tenga sentido.
    \end{itemize}
  \item Modelo básico:
    \begin{itemize}
      \item \textbf{Contenedores}: Estructuras que almacenan datos.
      \item \textbf{Iteradores}: Permite recorrer contenedores.
      \item \textbf{Algoritmos}: Manipulan datos independientemente de contenedores.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Contenedores}
\begin{itemize}
  \item Un \textbf{contenedor} almacena una secuencia de objetos.
  \begin{itemize}
    \item \textbf{Secuencias}: Permiten acceder a una secuencia (semiabierta) de objetos.
       \begin{itemize}
         \item \cppid{vector<T,A>}, \cppid{list<T,A>}, \cppid{forward\_list<T,A>}, \cppid{deque<T,A>}.
       \end{itemize}
    \item \textbf{Contenedores asociativos}: Permiten realizar búsquedas en pares clave valor.
      \begin{itemize}
        \item \textbf{Ordenados}: \cppid{map<K,V,C,A>}, \cppid{multimap<K,V,C,A>}, 
                                  \cppid{set<K,V,C,A>}, \cppid{multiset<K,V,C,A>}.
        \item \textbf{No ordenados}: \cppid{unordered\_map<K,V,C,A>}, \cppid{unordered\_multimap<K,V,C,A>}, 
                                     \cppid{unordered\_set<K,V,C,A>}, \cppid{unordered\_multiset<K,V,C,A>}.
      \end{itemize}
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Adaptadores y casi contenedores}
\begin{itemize}
  \item \textbf{Adaptadores de contenedores}: Adaptan la interfaz de un contenedor \cppid{C}.
    \begin{itemize}
      \item \cppid{priority\_queue<T,C,Cmp>}, \cppid{queue<T,C>}, \cppid{stack<T,C>}.
    \end{itemize}
  \item \textbf{Casi contenedores}: Secuencias con limitaciones.
    \begin{itemize}
      \item \textbf{Tamaño fijo}: \cppid{T[N]}, \cppid{array<T,N>}.
      \item \textbf{Secuencias de bits}: \cppid{bitset<N>}, \cppid{vector<bool>}.
      \item \textbf{Arrays numéricos}: \cppid{valarray<T>}.
      \item \textbf{Cadenas}: \cppid{basic\_string<C,Tr,A>}, \cppid{string}, \cppid{u16string},
            \cppid{u32string}.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Iteradores}
\begin{itemize}
  \item Un \textbf{iterador} generaliza la abstracción de puntero para realizar
        accesos indirectos.
  \item Muchos iteradores satisfacen el concepto de \cppid{InputIterator} o
        \emph{iterador de entrada}.
    \begin{itemize}
      \item Se puede avanzar: \cppid{++i}.
      \item Se puede acceder objeto apuntado: \cppid{x = *i}.
      \item Admiten comparación de igualdad: \cppid{i == j}, \cppid{i!=j}.
    \end{itemize}
  \item Algunos iteradores soportan más operaciones:
    \begin{itemize}
      \item \cppid{--i}, \cppid{i+n}, \cppid{i+=n}, \cppid{i[n]}, \cppid{i<j}, \ldots
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Iteradores y contenedores}
\begin{itemize}
  \item Todos los contenedores tienen definido un tipo de iterador asociado.
    \begin{itemize}
      \item Tipo \cppid{iterator}.
      \item \cppid{vector<int>::iterator}, \cppid{list<double>::iterator}, \cppid{deque<string>::iterator}, \ldots
    \end{itemize}
  \item Todos los contenedores tiene dos funciones miembro que definen su secuencia:
    \begin{itemize}
      \item \cppid{c.begin()}: Iterador al principio de la secuencia.
      \item \cppid{c.end()}: Iterador a \emph{uno-después-de} el final de la secuencia.
      \item Secuencias como intervalo semi-abierto \cppid{[inicio, fin)}.
    \end{itemize}
\end{itemize}
\begin{block}{Imprimir una lista de valores de contenedor c}
\begin{lstlisting}[]
for (auto i=c.begin(); i!=c.end(); ++i) {
  cout << *i << endl;
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Algoritmos}
\begin{itemize}
  \item El uso de iteradores permite definir algoritmos independientemente
        de contenedores.
\end{itemize}
\begin{block}{Buscar un valor}
\begin{lstlisting}[]
template <typename I, typename T>
I find(I prim, I ult, const T & x) {
  while (prim!=ult && *prim!=x) prim++
  return prim;
}
\end{lstlisting}
\end{block}
\pause
\begin{block}{Usando la búsqueda}
\begin{lstlisting}[]
bool tiene(vector<int> & v, int x) {
  auto p = find(v.begin(), b.end(), x);
  return p!=v.end();
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Algoritmos y predicados}
\begin{block}{Búsqueda con predicado}
\begin{lstlisting}[]
template <typename I, typename P>
I find_if(I prim, I ult, P pred) {
  while (first!=last && !pred(*first)) prim++;
  return first;
}
\end{lstlisting}
\end{block}
\pause
\begin{block}{Usando la búsqueda}
\begin{lstlisting}[]
vector<int> v{1,2,3,4,5,6,7,8};
auto p = find_if(v.begin(), v.end(), 
  [](int x) { return (x%2==0) && (x%3==0); });
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t]{Algoritmos en STL}
\begin{itemize}
  \item Gran variedad: 90 algoritmos.
  \vfill
  \item Clasificación:
    \begin{itemize}
      \item De secuencia: Modificación y no-modificación.
      \item Particionamiento, ordenación y búsqueda binaria.
      \item Operaciones de conjunto y montículo.
      \item Operaciones de mínimo y máximo.
      \item Operaciones numéricas.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Aplicando una operación a una secuencia}
\begin{itemize}
  \item Aplica un objeto función a cada elemento de una secuencia.
\end{itemize}
\begin{lstlisting}[]
template <typename I, typename F>
F for_each(I first, I last, F f);
\end{lstlisting}
\begin{block}{Ejemplo}
\begin{lstlisting}[]
vector<int> v{1,2,3,4,5,6,7,8};
for_each(begin(v), end(v), [](int x) {
    cout << x;
  });
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Copiando una secuencia}
\begin{itemize}
  \item Copia una secuencia en otra.
\end{itemize}
\begin{lstlisting}[]
template <typename I, typename O>
O copy(I first, I last, O first2);
\end{lstlisting}
\begin{block}{Ejemplo}
\begin{lstlisting}[]
vector<int> v{1,2,3,4,5,6,7,8};
vector<int> w;
w.resize(8);
copy(begin(v), end(v), begin(w)); // w tiene que tener espacio
vector<int> z;
copy(begin(v), end(v), back_inserter(w)); // Va insertando
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Transformación}
\begin{itemize}
  \item Transforma una secuencia en otra aplicando una operación
\end{itemize}
\begin{lstlisting}[]
template <typename I, typename O, typename F>
O transform(I first, I last, O first2, F unop);

template <typename I, typename O, typename F>
O transform(I first1, I last1, I first2, I last2,
            O first2, F binop);
\end{lstlisting}
\begin{block}{Ejemplo}
\begin{lstlisting}[]
vector<int> v{1,2,3,4,5,6,7,8};
vector<int> w;
transform(begin(v), end(v), back_inserter(w),
          [](int x) {return x*x}); 
vector<int> z;
transform(begin(v), end(v), begin(w), end(w),
          back_inserter(z),
          [](int x, int y) { return x+y; });
\end{lstlisting}
\end{block}
\end{frame}
